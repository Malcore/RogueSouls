import libtcodpy as libtcod
import random
import object

# Global variables
LIMIT_FPS = 20

# actual size of the window
SCREEN_WIDTH = 80
SCREEN_HEIGHT = 60

# size of the map
MAP_WIDTH = 80
MAP_HEIGHT = 45

# stat bars
BAR_LENGTH = 20
PANEL_HEIGHT = 12
PANEL_Y = SCREEN_HEIGHT - PANEL_HEIGHT

# message log
MSG_X = BAR_LENGTH + 2
MSG_WIDTH = SCREEN_WIDTH - BAR_LENGTH - 2
MSG_HEIGHT = PANEL_HEIGHT - 2


class Character:
    # defines something that can take combat actions (e.g. any living character) and gives them combat statistics as
    # well as defining actions they can take during combat
    def __init__(self, hit_points, focus_points, stamina, vig, att, end, str, dex, int, fai, luc, wil, equip_load,
                 poise, item_dis, att_slots, dmg_r1, dmg_r2, dmg_r3, dmg_l1, dmg_l2, dmg_l3, def_phys, def_strike,
                 def_slash, def_thrust, def_mag, def_fire, def_lightn, def_dark, res_bleed, res_poison, res_frost,
                 res_curse, bleed_amt, poison_amt, frost_amt, curse_amt, facing, x, y, curr_r, curr_l, blocking, level,
                 soul_value):
        self.hit_points = hit_points
        self.focus_points = focus_points
        self.stamina = stamina
        self.vig = vig
        self.att = att
        self.end = end
        self.str = str
        self.dex = dex
        self.int = int
        self.fai = fai
        self.luc = luc
        self.wil = wil
        self.equip_load = equip_load
        self.poise = poise
        self.item_dis = item_dis
        self.att_slots = att_slots
        self.dmg_r1 = dmg_r1
        self.dmg_r2 = dmg_r2
        self.dmg_r3 = dmg_r3
        self.dmg_l1 = dmg_l1
        self.dmg_l2 = dmg_l2
        self.dmg_l3 = dmg_l3
        self.def_phys = def_phys
        self.def_strike = def_strike
        self.def_slash = def_slash
        self.def_thrust = def_thrust
        self.def_mag = def_mag
        self.def_fire = def_fire
        self.def_lightn = def_lightn
        self.def_dark = def_dark
        self.res_bleed = res_bleed
        self.res_poison = res_poison
        self.res_frost = res_frost
        self.res_curse = res_curse
        self.bleed_amt = bleed_amt
        self.poison_amt = poison_amt
        self.frost_amt = frost_amt
        self.curse_amt = curse_amt
        self.facing = facing
        self.x = x
        self.y = y
        self.curr_r = curr_r
        self.curr_l = curr_l
        self.blocking = blocking
        self.level = level
        self.soul_value = soul_value

    def attack(self, wep_side, att_type):
        target = in_front(self, self.facing)
        if target:
            self.att_damage(target, wep_side, att_type)

    def block(self):
        self.blocking = True

    def unblock(self):
        self.blocking = False

    def dodge(self):
        # TODO
        return

    def att_damage(self, target, wep_side, att_type):
        if wep_side is "right":
            type_list = self.curr_r.dmgtype
            eff_list = self.curr_r.effects
            if "phys" in type_list:
                deal_phys_dmg(target, self.curr_l, att_type)
            if "mag" in type_list:
                deal_mag_dmg(target, self.curr_r)
            if "fire" in type_list:
                deal_fire_dmg(target, self.curr_r)
            if "lightn"in type_list:
                deal_lightn_dmg(target, self.curr_r)
            if "dark" in type_list:
                deal_dark_dmg(target, self.curr_r)
            if "bleed" in eff_list:
                add_bleed(target, self.curr_r)
            if "poison" in eff_list:
                add_poison(target, self.curr_r)
            if "frost" in eff_list:
                add_frost(target, self.curr_r)
            if "curse" in eff_list:
                add_curse(target, self.curr_r)
        if wep_side is "left":
            type_list = self.curr_l.dmgtype
            eff_list = self.curr_r.effects
            if "phys" in type_list:
                deal_phys_dmg(target, self.curr_l, att_type)
            if "mag" in type_list:
                deal_mag_dmg(target, self.curr_l)
            if "fire" in type_list:
                deal_fire_dmg(target, self.curr_l)
            if "lightn"in type_list:
                deal_lightn_dmg(target, self.curr_l)
            if "dark" in type_list:
                deal_dark_dmg(target, self.curr_l)
            if "bleed" in eff_list:
                add_bleed(target, self.curr_l)
            if "poison" in eff_list:
                add_poison(target, self.curr_l)
            if "frost" in eff_list:
                add_frost(target, self.curr_l)
            if "curse" in eff_list:
                add_curse(target, self.curr_l)


#################################
# deal different types of damage
#################################
def deal_phys_dmg(target, curr_wep, att_type):
    dmg_reduc = target.def_phys / 100
    if target.blocking:
        dmg_reduc += target.curr_l.def_phys / 100
    if att_type is "slash":
        dmg_reduc += target.def_slash / 100
    elif att_type is "strike":
        dmg_reduc += target.def_slash / 100
    elif att_type is "thrust":
        dmg_reduc += target.def_slash / 100
    if dmg_reduc > 1:
        dmg_reduc = 1
    target.hp -= curr_wep.dmg_phys - round(dmg_reduc * curr_wep.dmg_phys)


def deal_mag_dmg(target, curr_wep):
    dmg_reduc = target.def_mag / 100
    if dmg_reduc > 1:
        dmg_reduc = 1
    target.hp -= curr_wep.dmg_mag - round(dmg_reduc * curr_wep.dmg_mag)


def deal_fire_dmg(target, curr_wep):
    dmg_reduc = target.def_fire / 100
    if dmg_reduc > 1:
        dmg_reduc = 1
    target.hp -= curr_wep.dmg_fire - round(dmg_reduc * curr_wep.dmg_fire)


def deal_lightn_dmg(target, curr_wep):
    dmg_reduc = target.def_lightn / 100
    if dmg_reduc > 1:
        dmg_reduc = 1
    target.hp -= curr_wep.dmg_lightn - round(dmg_reduc * curr_wep.dmg_lightn)


def deal_dark_dmg(target, curr_wep):
    dmg_reduc = target.def_dark / 100
    if dmg_reduc > 1:
        dmg_reduc = 1
    target.hp -= curr_wep.dmg_dark - round(dmg_reduc * curr_wep.dmg_dark)


#################################
# functions for damage effects
#################################
def add_bleed(target, curr_wep):
    target.bleed_amt += curr_wep.eff_bleed - round(target.res_bleed / 100 * curr_wep.eff_bleed)


def add_poison(target, curr_wep):
    target.poison_amt += curr_wep.eff_poison - round(target.res_poison / 100 * curr_wep.eff_poison)


def add_frost(target, curr_wep):
    target.frost_amt += curr_wep.eff_frost - round(target.res_frost / 100 * curr_wep.eff_frost)


def add_curse(target, curr_wep):
    target.curse_amt += curr_wep.eff_curse - round(target.res_curse / 100 * curr_wep.eff_curse)


############################################
# helper functions for game actions
############################################
def in_front(self, dir):
    if dir is "north":
        return occupied(self.x, self.y - 1)
    if dir is "east":
        return occupied(self.x + 1, self.y)
    if dir is "south":
        return occupied(self.x, self.y + 1)
    if dir is "west":
        return occupied(self.x - 1, self.y)


def occupied(x, y):
    for obj in objects:
        if obj.x is x and obj.y is y:
            return obj
    return None


############################################
# main menu and game functions
############################################
def new_game():
    global player, inventory, game_msgs, game_state, dungeon_level, CHARACTER_CREATED, POINT_POOL, unique_effect_list

    # create object representing the player
    player_component = Player(level = 1, hunger = 'Full')
    fighter_component = Fighter(dv = 0, pv = 0, hp_dice = 'd6', attack_rating = 0, damage_dice = 2, num_dmg_dice = 1, xp = 0, regen = 10,
        death_function = player_death, str = PLY_STR, dex = PLY_DEX, con = PLY_CON, int = PLY_INT, wis = PLY_WIS, cha = PLY_CHA, spd = 30, level = 1)
    player = Object(0, 0, '@', libtcod.white, 'player', blocks = True, fighter = fighter_component, player = player_component)

    # generate map (at this point it's not drawn to the screen)
    dungeon_level = 1
    make_map()

    game_state = 'playing'

    CHARACTER_CREATED = False
    POINT_POOL = 21

    # list of Items in player's inventory
    inventory = []

    # create the list of game messages and their colors, starts empty
    game_msgs = []

    # a list of player stats for listing on the main console
    player_stats = []

    # list of unique effects current on the player
    unique_effect_list = []

    # a warm welcome message!
    message('Have Lots of Fun Courtney Please Don\'t Cry This Game Is Really Cool')

    initialize_fov()

    # initial equipment: a dagger
    wep_equipment_component = Equipment(slot='right hand', damage_dice = 4, type = '1-hand')
    wep_item_component = Item(weight = 1, use_function = None, equipment = wep_equipment_component)
    wep_obj = Object(0, 0, '(', color = libtcod.gray, name = 'dagger', always_visible = True, item = wep_item_component)

    shld_equipment_component = Equipment(slot='left hand', dv_bonus = 4, type = '1-hand')
    shld_item_component = Item(weight = 5, use_function = None, equipment = shld_equipment_component)
    shld_obj = Object(0, 0, '[', color = libtcod.darker_orange, name = 'wooden buckler', always_visible = True, item = shld_item_component)

    arm_equipment_component = Equipment(slot='body', dv_bonus = 2, type = 'armor')
    arm_item_component = Item(weight = 10, use_function = None, equipment = arm_equipment_component)
    arm_obj = Object(0, 0, '[', color = libtcod.darker_green, name = 'leather armor', always_visible = True, item = arm_item_component)

    inventory.append(wep_obj)
    inventory.append(shld_obj)
    inventory.append(arm_obj)
    wep_equipment_component.equip()
    shld_equipment_component.equip()
    arm_equipment_component.equip()


def initialize_fov():
    global fov_recompute, fov_map

    libtcod.console_clear(con)

    fov_recompute = True

    # create the FOV map, according to the generated map
    fov_map = libtcod.map_new(MAP_WIDTH, MAP_HEIGHT)
    for y in range(MAP_HEIGHT):
        for x in range(MAP_WIDTH):
            libtcod.map_set_properties(fov_map, x, y, not map[x][y].block_sight, not map[x][y].blocked)


def from_dungeon_level(table):
    # returns a value that depends on level. the table specifies what value occurs after each level, default is 0.
    for (value, level) in reversed(table):
        if dungeon_level >= level:
            return value
    return 0


def play_game():
    global key, mouse, CHARACTER_CREATED

    player_action = None

    mouse = libtcod.Mouse()
    key = libtcod.Key()

    while not libtcod.console_is_window_closed():

        libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS|libtcod.EVENT_MOUSE, key, mouse)

        # render the screen
        render_all()

        libtcod.console_flush()

        while CHARACTER_CREATED == False:
            check_character_creation()

        # check to see if the player leveled up
        check_level_up()

        if game_state is not 'dead':
            check_player_alive()

        # erase all objects at their old locations, before they move
        for object in objects:
            object.clear()

        # handle keys and exit game if needed
        player_action = handle_keys()
        if player_action == 'exit':
            save_game()
            break

        # let the creatures take their turn
        if game_state == 'playing' and player_action != 'didnt-take-turn':
            for object in objects:
                if object.ai:
                    object.ai.take_turn()


def random_choice_index(chances):  #choose one option from list of chances, returning its index
    # the dice will land on some number between 1 and the sum of the chances
    dice = random.randint(1, sum(chances))

    # go through all chances, keeping the sum so far
    running_sum = 0
    choice = 0
    for w in chances:
        running_sum += w

        # see if the dice landed in the part that corresponds to this choice
        if dice <= running_sum:
            return choice
        choice += 1


def random_choice(chances_dict):
    # choose one option from dictionary of chances, returning its key
    chances = chances_dict.values()
    strings = chances_dict.keys()
    return strings[random_choice_index(chances)]


def main_menu():
    img = libtcod.image_load('menu_background.png')

    while not libtcod.console_is_window_closed():
        # show the background image at twice the regular resolution
        libtcod.image_blit_2x(img, 0, 0, 0)

        # show the game's title and some credits!
        libtcod.console_set_default_foreground(0, libtcod.light_yellow)
        libtcod.console_print_ex(0, SCREEN_WIDTH/2, SCREEN_HEIGHT/2-4, libtcod.BKGND_NONE, libtcod.CENTER, 'RogueSouls')
        libtcod.console_print_ex(0, SCREEN_WIDTH/2, SCREEN_HEIGHT-2, libtcod.BKGND_NONE, libtcod.CENTER, 'By Malcore')

        # show options and wait for the player's choice
        choice = menu(0, 5, '', ['Play a new game', 'Continue last game', 'Quit'], 24)

        # new game
        if choice == 0:
            new_game()
            play_game()
        # load game
        elif choice == 1:
            try:
                load_game()
            except:
                msgbox('\n No saved game to load \n', 24)
                continue
            play_game()
        # quit
        elif choice == 2:
            break


def menu(xOff, yOff, header, options, width, must_choose = False, opaque = 0.7, extra_height = 0):
    if len(options) > 26:
        raise ValueError('Cannot have more than 26 options.')
    header_height = libtcod.console_get_height_rect(con, 0, 0, width, SCREEN_HEIGHT, header)
    if header == '':
        header_height = 0
    height = len(options) + header_height + extra_height

    # create an off-screen console that represents the menu's window
    window = libtcod.console_new(width, height)

    # print the header, with auto-wrap
    libtcod.console_set_default_foreground(window, libtcod.white)
    libtcod.console_print_rect_ex(window, 0, 0, width, height, libtcod.BKGND_NONE, libtcod.LEFT, header)

    # print all the options
    y = header_height
    letter_index = ord('a')
    for option_text in options:
        text = '(' + chr(letter_index) + ') ' + option_text
        libtcod.console_print_ex(window, 0, y, libtcod.BKGND_NONE, libtcod.LEFT, text)
        y += 1
        letter_index += 1

    # blit the contents to the root console
    x = SCREEN_WIDTH/2 - width/2 + xOff
    y = SCREEN_HEIGHT/2 - height/2 + yOff
    libtcod.console_blit(window, 0, 0, width, height, 0, x, y, 1.0, opaque)

    # wait for player input before acting
    libtcod.console_flush()
    key = libtcod.console_wait_for_keypress(True)

    if key.vk is libtcod.KEY_ENTER and key.vk is libtcod.lalt:
        # Alt+Enter: toggle fullscreen
        libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())

    # convert the ASCII code to an index; if it corresponds to an option, return it
    while must_choose is True:
        key = libtcod.console_wait_for_keypress(True)
        index = key.c - ord('a')
        if index > len(options) or index < 0:
            pass
        if 0 <= index < len(options):
            return index

    if must_choose is False:
        key = libtcod.console_wait_for_keypress(True)
        index = key.c - ord('a')
        if 0 <= index < len(options):
            return index

    return None


def msgbox(text, width=0):
    # use menu() as a sort of "message box"
    menu(0, 0, text, [], width)


# Initialization of game-state variables and game functions
objects = []

libtcod.console_set_custom_font('terminal10x10_gs_tc.png', libtcod.FONT_TYPE_GREYSCALE | libtcod.FONT_LAYOUT_TCOD)
libtcod.console_init_root(SCREEN_WIDTH, SCREEN_HEIGHT, 'First Python Roguelike', False)
con = libtcod.console_new(SCREEN_WIDTH, SCREEN_HEIGHT)
panel = libtcod.console_new(SCREEN_WIDTH, PANEL_HEIGHT)

libtcod.sys_set_fps(LIMIT_FPS)

main_menu()
